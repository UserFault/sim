++ Задача Создать Механизм Доступа К Солюшену
[template: ШаблонКарточкиЗадачи]

+++Состояние задачи
* Выполнено 23.12.2018 1:42:39

+++Задание
Создать механизм доступа к Солюшену из произвольного места кода Движка.

+++Зависит от
* Надо собрать класс MSolutionSettings полностью.
* сначала надо создать (хотя бы пустые) функции Входной группы солюшена, а то некуда добавлять код.
* Солюшен должен компилироваться.

++Материалы
* см wikirel://../../../Справочники/ДвижокТаппВики/ДвижокТаппВики.wiki?page=СсылкаЯчейкиНаКонтейнер

+++Обсуждение и принятые решения
Ранее для этого использовалась статическая ссылка на объект Движка. Она была доступна из любого места кода и часто использовалась везде.
Но это хорошо когда в процессе открыт только один солюшен. Если же их несколько, эта ссылка должна будет перезаписываться каждым новым солюшеном. Хотя, может и нет.
И к тому же, теперь ожидается, что солюшены между собой будут связаны, а значит, в каждом солюшене будут существовать связи с другими солюшенами. И эти другие солюшены тоже надо как-то находить и использовать.

Теперь я создал класс MSolutionRefCollection, который должен статически существовать в единственном экземпляре и по ИД Солюшена выдавать нужный объект Солюшена.
 * *Вывод:* Каждая операция с ячейками и связями должна принимать идентификатор солюшена или ссылку на объект Солюшена как один из аргументов. Ведь для доступа к солюшену нужен его идентификатор. 
Но вот вопрос: Этот класс MSolutionRefCollection, как набор данных, существует один для всех солюшенов в процессе, или для каждого свой получается? Чтобы это узнать, надо собрать наскоро и тестировать Движок в части открытия нескольких Солюшенов.

23.12.2018 0:41:49 выполнил тест - все одновременно открытые солюшены в одном процессе и одной сборке движка собираются в этой одной коллекции MSolutionRefCollection. Это и ожидалось. А вот классы из разных сборок Движков будут по коллекциям своих сборок расходиться. 
1. Следовательно, сейчас нельзя в одном процессе держать два солюшена на разных сборках движка и связывать их друг с другом. Для такого дела надо выносить один общий объект куда-то и его запрашивать из каждого движка. То есть, это сторонний сервер РегистраторСолюшенов из концепции многоконтейнерности Тапп должен быть.
  * *Вывод:* Обрабатывать одновременно два и более Солюшенов одним Движком можно, разными Движками - нельзя. В этой версии Тапп.
2. Движок в этой версии не умеет находить Солюшены по их идентификатору и загружать в свой процесс. Для этого нужно знать, где эти Солюшены находятся, а для этого нужен какой-то внешний относительно Движка механизм, вроде РегистраторССолюшенов.  
  * *Вывод:* Сейчас все связанные Солюшены должны быть заранее загружены в один процесс.
    * Это несложно, если известно расположение каждого из них. Как у меня с Хранилищами. Но все же, заранее загружать все Солюшены не нужно, если добавить в Движок возможность подгрузки Солюшена, которого нет в MSolutionRefCollection. Хотя, загружать солюшены должно приложение, наверно - кто же их выгружать будет - это же совсем другая схема работы получится. Хотя возможно. Но это на последующие релизы Движка Тапп Бар отложить следует.
        * *Вывод:* Можно реализовать самостоятельную загрузку Движком требуемых Солюшенов, если предоставить ему список размещений этих Солюшенов, их идентификаторы. Движок также самостоятельно может их выгружать, сделав все использование связанных Солюшенов скрытым от пользователя. Но решено отложить это на последующие (под)версии Движка Тапп Бар как усовершенствование.


+++Выполняемые действия
++++1. Создать класс MSolutionRefCollection
    /// <summary>
    /// Коллекция ссылок на объекты разных Солюшенов
    /// </summary>
    /// <remarks>
    /// Этот класс проектируется впервые и может содержать непроверенные решения.
    /// Это полностью статический класс, который создается при создании солюшена.
    /// Он либо изолирует, либо объединяет ссылки на солюшены, открытые в процессе движка.
    /// И размечает доступ к контейнеру для ячейки или связи в мультиконтейнерной или сетевой конфигурации движка.
    /// </remarks>
    public static class MSolutionRefCollection
    {
        private static Dictionary<int, MSolution> dictionary;

        /// <summary>
        /// NT-Добавить ссылку на объект Солюшена в коллекцию
        /// </summary>
        /// <param name="solutionRef">Ссылка на объект Солюшена</param>
        /// <exception cref="SimEngineException">Другой объект Солюшена с тем же ИД уже существует</exception>
        internal static void AddSolutionReference(MSolution solutionRef)
        {
            //create new dictionary if not exists
            if (dictionary == null)
                dictionary = new Dictionary<int, MSolution>();
            //add ref to dictionary if not exists
            int key = solutionRef.SolutionId;
            if (dictionary.ContainsKey(key))
            {
                //проверить что это тот же объект солюшена, с тем же адресом в памяти.
                //если нет - выдать исключение
                MSolution sol = dictionary[key];
                if (sol != solutionRef) //TODO: тут сравнить адреса объектов в памяти
                    throw new SimEngineException("Другой объект Солюшена с тем же ИД уже существует");
            }
            else
            {
                dictionary.Add(key, solutionRef);
            }

            return;
        }
        /// <summary>
        /// NT-Получить ссылку на объект Солюшена по его идентификатору
        /// </summary>
        /// <param name="id">Идентификатор Солюшена</param>
        /// <returns>Возвращает ссылку на объект Солюшена или выбрасывает исключение, если объект не найден в коллекции.</returns>
        /// <exception cref="SimEngineException">Коллекция не инициализирована или Солюшен не найден</exception>
        public static MSolution GetSolutionReference(int id)
        {
            if(dictionary == null)
                throw new SimEngineException("Коллекция Солюшенов не инициализирована");
            
            if (dictionary.ContainsKey(id))
            {
                //проверить что это тот же объект солюшена, с тем же адресом в памяти.
                //если нет - выдать исключение
                MSolution sol = dictionary[id];
                return sol;
            }
            else
                throw new SimEngineException("Объект Солюшена не найден в коллекции солюшенов");
        }

        /// <summary>
        /// NT-Удалить ссылку на Солюшен
        /// </summary>
        /// <param name="solutionRef">Ссылка на объект Солюшена</param>
        /// <param name="throwIfNotExists">
        /// True - Выбрасывать исключение если Коллекция не инициализирована или Солюшен с таким идентификатором  не найден.
        /// False - Не выбрасывать исключение.
        /// </param>
        /// <exception cref="SimEngineException">Коллекция не инициализирована или Солюшен не найден</exception>
        internal static void RemoveSolutionReference(MSolution solutionRef, bool throwIfNotExists)
        {
            //create new dictionary if not exists
            if (dictionary == null)
            {
                //TODO: Решить, тут молча выйти или выбросить исключение об ошибке, ведь ни одного солюшена нет?
                if (throwIfNotExists) 
                    throw new SimEngineException("Коллекция Солюшенов не инициализирована");
                else
                    return;
            }
            //remove ref from dictionary if exists
            int key = solutionRef.SolutionId;
            if (!dictionary.ContainsKey(key))
            {
                //TODO: Решить, тут молча выйти или выбросить исключение об ошибке, ведь указанного солюшена нет?
                if (throwIfNotExists)
                    throw new SimEngineException("Объект Солюшена не найден в коллекции солюшенов");
                else
                    return;
            }
            dictionary.Remove(key);

            return;
        }
    }

++++2. добавить код в MSolution.SolutionOpen()
            //Добавить ссылку на солюшен в MSolutionRefCollection при открытии солюшена
            MSolutionRefCollection.AddSolutionReference(this);
++++3. добавить код в MSolution.SolutionClose()
            //Удалить ссылку на солюшен из MSolutionRefCollection при закрытии солюшена
            MSolutionRefCollection.RemoveSolutionReference(this, true);//false - игнорировать отсутствие, true - исключение при отсутствии.
++++4. Написать функцию теста в приложении Test, запустить и отладить.
        private static void TestSolutionRefCollection()
        {
            String file1 = "C:\\Temp\\sol1.txt";
            String file2 = "C:\\Temp\\sol2.txt";
            String file3 = "C:\\Temp\\sol3.txt";

            //1 create 3 new solution
            MSolutionSettings s1 = new MSolutionSettings(file1);
            s1.SolutionId = 1;
            s1.Save();
            MSolutionSettings s2 = new MSolutionSettings(file2);
            s2.SolutionId = 2;
            s2.Save();
            MSolutionSettings s3 = new MSolutionSettings(file3);
            s3.SolutionId = 3;
            s3.Save();
            s1 = null; s2 = null; s3 = null;
            //2 open 3 solution
            MSolution d1 = new MSolution();
            d1.SolutionOpen(file1);
            MSolution d2 = new MSolution();
            d2.SolutionOpen(file2);
            MSolution d3 = new MSolution();
            d3.SolutionOpen(file3);
            //3 check solution list and access
            MSolution da1 = MSolutionRefCollection.GetSolutionReference(1);
            MSolution da2 = MSolutionRefCollection.GetSolutionReference(2);
            MSolution da3 = MSolutionRefCollection.GetSolutionReference(3);
            //4 exit
            d1.SolutionClose(true);
            d2.SolutionClose(true);
            d3.SolutionClose(true);
            
            return;
        }

+++Отзывы
Оказались ли принятые решения правильными и почему/почему нет.

+++Документация
Если в Солюшене есть ячейки, имеющие связи с ячейками, расположенными в другом солюшене, то для работы с ними нужен объект другого Солюшена. Надо его загрузить в память заранее. Тогда по идентификатору Солюшена в идентификаторе ячейки или связи можно получить этот другой Солюшен и передать туда вызов операции.

В старой версии Движка для доступа к объекту контейнера из кода ячеек и связей использовалась статическая ссылка на объект Движка. Такая статическая ссылка может использоваться в любом месте кода. Это сильно упрощало работу Движка.
В новой версии Движка предполагается, что в одном процессе может быть открыто несколько Солюшенов. Статическая ссылка на Солюшен в этом случае будет перезаписываться каждым вновь открываемым Солюшеном. Этот способ теперь нельзя использовать.
Поэтому теперь я создал класс MSolutionRefCollection, который должен статически существовать в Движке в единственном экземпляре и по ИД Солюшена выдавать нужный объект Солюшена.

Устроен он просто: 
* Есть статический словарь солюшенов, который инициализируется при первой операции добавления.
  Ключом в словаре является идентификатор солюшена. 
* Есть операция добавления солюшенов. Когда солюшен открывается, он  этой функцией добавляется в словарь солюшенов.
* Есть операция удаления солюшенов из словаря. Когда Солюшен закрывается, он этой функцией удаляется из словаря солюшенов.
* Есть функция получения объекта Солюшена по его идентификатору солюшена. 


 