++ Задача Разработать Солюшен Read Only
[template: ШаблонКарточкиЗадачи]

+++Состояние задачи
* Написать документацию 25.12.2018 0:05:36

+++Задание
Нужно разработать режим Солюшена только для чтения.
Например, когда Солюшен записан на компакт-диск.
Нужно придумать, как это будет работать и будет ли.

+++Зависимости
Добавить зависимости текущей задачи

+++Материалы
нет


+++Обсуждение и принятые решения
Солюшен может оказаться на защищенном от записи диске.
Надо обеспечить его работу в таком случае.
- обнаружить режим Только чтение записью пробного файла в каталог Солюшена.
  И выставить флаг Только чтение в свойствах Солюшена.
- файловую БД надо открыть в режиме только чтение. Если это возможно.
- серверную БД можно использовать как обычно, но возможны сбои, 
  если ее файлы тоже рид-онли.
- каталог лога перенести в системный Temp, если он ранее был назначен на неперезаписываемый каталог.
- код должен отклонять операции, изменяющие состояние Солюшена.
- ... у меня есть где-то пример такого устройства. Надо его найти. Хранилища?
------------------------
 Солюшен должен иметь возможность открываться только для чтения, чтобы он не портился клиентским кодом.
      И он может оказаться (находиться) на диске, где запись невозможна.
      И с ним тоже надо иметь возможность работать в этом случае.
      (либо пользователь указывает при открытии солюшена режим реад-онли, либо движок определяет при открытии невозможность записи, 
       но в итоге движок работает в режиме реад-онли, и пользователь должен иметь возможность получить информацию об этом.
       Проще всего в движок сделать проперти реад-онли. 
       Если пользователь при запуске указал не-реад-онли, то движок проверяет возможность записи.
       Если возможности записи нет, движок выставляет реад-онли флаг сам.
       А код движка в любом случае должен работать с учетом этого флага.
       Выбрасывает исключение, если реад-онли активен, а операция требует изменения данных.
------------------------
Удобно было бы, чтобы Солюшен мог работать с компакт-диска или подобного носителя информации.
* Собственно тут может быть два разных значения этого выражения:
    А) Солюшен не способен изменять свое состояние при работе.
    Б) Солюшен не должен изменять свое состояние при работе.
  Надо как-то их разделить в понимании и как-то попытаться реализовать.

++++Случай Солюшен не способен изменяться
* Это проверяется при открытии Солюшена:
    * Если Каталог Солюшена не позволяет создать файл.
    * Если БД Солюшена не может быть открыта в режим только чтение. Не каждая БД поддерживает такой режим.
* Надо убедиться, что БД Солюшена может работать в режиме Только Чтение. Для этого можно запросить АдаптерБД. Адаптер для конкретной СУБД вернет флаг, что он может или не может работать в режиме только-чтение.
    * Аксцесс может работать. 
    * MySQL MsSQL и вообще серверные СУБД могут работать, наверно. 
    * NoDatabase всегда способен работать. 
    * Для остальных типов БД еще надо узнать, как их запускать в режиме только-чтение.
* тогда и другие каталоги и подсистемы надо автоматически переназначать на места, доступные для записи. Например, каталог Лога. Потом эти логи будут потеряны, но и хрен с ним. Солюшен же все равно не изменяется.
* ФайлСолюшена не сможет сохранять свое состояние. Обычно он сохраняется при закрытии Солюшена, а тут это вызовет исключение.
    * Следовательно, Файл Солюшена не должен сохраняться, если Солюшен находится в режиме Только Чтение.  

++++Случай Солюшен не должен изменяться      
* Тут пользователь не желает, чтобы Солюшен изменялся. 
* Проверки могут показать, что Солюшен способен изменяться, но пользователь сам установил режим Только чтение.
  
++++Итоги
* Дальнейшее  поведение этих двух вариантов вроде бы одинаковое: Флаг Солюшена Только Чтение установлен, и все операции его учитывают.
* Значит, это выглядит так:
1. Пользователь вызывает SolutionOpen() с флагом только Чтение
2. Если пользователь указал флаг Только чтение, то проверка, может ли солюшен изменяться, не делается.
3. Если пользователь не указал флаг Только чтение, то проверка делается. По ее результатам устанавливается флаг Только чтение.
4. Солюшен начинает работу с учетом состояния флага Только чтение. 

Тут есть еще проблема: значение флага Только Чтение запоминается в файле Солюшена. Но если солюшен открыт в режиме только чтение, то флаг не запоминается, так как запись в файл солюшена не должна производиться. Получается, можно открыть солюшен для записи и установить для него флаг только чтение, а потом нельзя его так же сбросить - так как новое значение не будет записано?
    * Получается, этот флаг - только для индикации режима Солюшена. Открывается же Солюшен либо по факту, либо принудительно в режиме только чтение.  Значит, флаг в Настройки Солюшена незачем пытаться устанавливать или сбрасывать извне солюшена. Его надо объявить public get, internal set. Но тогда он не будет загружаться из файл Солюшена. Это надо проверить не будет ли это вызывать исключение при загрузке настроек из файла Солюшена.
        * Если выводить в ХМЛ и загружать вручную, а не через помощник фреймворка, то можно обойти все эти проблемы. 
    
Определять режим солюшена надо где-то после загрузки Настроек Солюшена, создания Адаптера БД, но до открытия адаптера БД и до инициализации лога, что вообще-то неудобно, так как лог должен самым первым открываться, чтобы в него все события писать. Наверно, при открытии Лога надо проверять что каталог Лога доступен на запись. И если нет, то надо решить: подменить каталог лога на временный и доступный для записи, или выдать исключение как сообщение об ошибке. А еще, указанный каталог лога может не существовать, и тогда тоже надо что-то делать. Но это я потом придумаю, когда доберусь до подсистемы Лога.    

++++Решения
 * Солюшен должен иметь поле bool Режим Только-Чтение. Оно будет использоваться каждой функцией контейнера, поэтому доступ к нему надо сделать быстрым.
 * Проперти этого поля в Настройки Солюшена должно быть как public get, internal set.
 * функция MSolution.SolutionOpen(...) должна иметь параметр - флаг Открыть только для чтения. Чтобы пользователь указал, хочет ли он открыть солюшен только для чтения. Можно сделать одну перегрузку функции с этим  параметром.
 * нужна функция проверки возможности изменения Солюшена по каталогу и БД. Надо придумать для нее название.
 * Адаптер БД, выбранный для Солюшена, должен предоставить флаг, может ли он работать в режиме только чтение.
    * Соответствующую функцию надо ввести в базовый класс адаптера БД.
    * Аксцесс может работать, я пробовал.
    * NoDatabase может работать, так как на временные ячейки флаг только чтение не распространяется. Только сохранение их не работает.
    * серверные БД, теоретически, всегда способны работать - ведь файлы БД обычно хранятся на сервере БД, а не в папке солюшена.
    * другие файловые бд - надо выяснять отдельно. Но их у меня в Тапп Бар пока нет.   
 * Надо убедиться, что Файл Солюшена нормально читается при открытии солюшена.
 * Если Солюшен находится в режиме Только-Чтение, то сразу же при открытии Солюшена каталог лога заменяется на подкаталог в С:\Темп, а при закрытии Солюшена Настройки Солюшена не сохраняются в Файл Солюшена.
 * todo: Надо спроектировать код для этого всего, особенно функцию определения состояния солюшена, и тогда уже вести сюда более точные данные. 
 * Адаптер БД тоже должен иметь локальный флаг read-only, который он получает при открытии адаптера, извлекая его из объекта Настройки Солюшена.    

+++Выполняемые действия
todo: Перечислить действия, выполняемые для реализации Задачи. Это самое важное.
С помощью этих сведений я могу затем тупо повторить их и заново собрать Движок.
Привести готовые листинги кода классов если можно.
++++1. Добавить поля и проперти в MSolutionSettings
        /// <summary>
        /// Солюшен в режиме Только чтение
        /// </summary>
        private bool m_SolutionReadOnly;
        /// <summary>
        /// Каталог БД Солюшена
        /// </summary>
        private String m_SolutionDatabaseDirectory;
        
        ...
        
        /// <summary>
        /// Солюшен в режиме Только чтение
        /// </summary>
        [Category("Solution properties"), Description("Solution Read-Only state")]
        public bool SolutionReadOnly
        {
            get { return m_SolutionReadOnly; }
            set { m_SolutionReadOnly = value; }
        }
        
        /// <summary>
        /// Каталог БД Солюшена
        /// </summary>
        /// <remarks>
        /// Предварительно должен быть установлен путь к Файлу Солюшена!
        /// </remarks>
        [Category("Solution folders"), Description("Solution database folder path")]
        public String SolutionDatabaseDirectory
        {
            get { return Bar.Utility.MUtility.makeAbsolutePath(this.getCurrentSolutionDirectory(), m_SolutionDatabaseDirectory); }
            set { m_SolutionDatabaseDirectory = Bar.Utility.MUtility.makeRelativePath(this.getCurrentSolutionDirectory(), value); }
        }
        //TODO: добавить так же другие пути каталогов Солюшена

        /// <summary>
        /// Каталог Солюшена
        /// </summary>
        /// <remarks>
        /// Предварительно должен быть установлен путь к Файлу Солюшена!
        /// </remarks>
        [Category("Solution folders"), Description("Solution directory path")]
        public String SolutionDirectory
        {
            get { return this.getCurrentSolutionDirectory(); }
        }
        
        //добавить инициализацию в конструктор класса
        
        /// <summary>
        /// Конструктор по умолчанию
        /// </summary>
        public MSolutionSettings()
        {
            ...
            this.m_SolutionReadOnly = false;//by default
            this.m_SolutionDatabaseDirectory = String.Empty;
            ...
        }
 
++++2. Добавить код в MSolution
        /// <summary>
        /// Солюшен в режиме Только чтение
        /// </summary>
        /// <remarks>
        /// Проперти берет значение из Настроек Солюшена
        /// </remarks>
        public bool SolutionReadOnly
        {
            get { return m_Settings.SolutionReadOnly; } //TODO: если будет часто вызываться, надо будет кешировать значение в переменной класса.
            set { this.m_Settings.SolutionReadOnly = value; }
        }
        
        /// <summary>
        /// NT-Провести проверку режима ТолькоЧтение Солюшена при открытии Солюшена
        /// </summary>
        /// <param name="readOnly">Флаг режима ТолькоЧтение, желаемый пользователем</param>
        /// <returns>Возвращает флаг режима ТолькоЧтение Солюшена</returns>
        private bool checkReadOnlyMode(bool readOnly)
        {
            //Если пользователь указал флаг Только чтение, то проверка, может ли солюшен изменяться, не делается.
            if (readOnly == true) return true;
            //Если пользователь не указал флаг Только чтение, то проверка делается. 
            //По ее результатам устанавливается флаг Только чтение.
            bool result = false;
            //* Если Каталог Солюшена не позволяет создать файл.
            bool res1 = Bar.Utility.MUtility.isFolderWritable(this.m_Settings.getCurrentSolutionDirectory());
            //* или Если БД Солюшена не может быть открыта в режим только чтение.
            bool res2 = this.m_DbAdapter.isCanWorkAtReadOnly();
            //поскольку каталог с БД может находиться вне каталога Солюшена, то она может оказаться вполне работоспособной.
            //но сейчас это неважно - если каталог Солюшена недоступен для записи, то весь солюшен считается Read-only.
            //потом это можно будет переделать, если потребуется.

            result = (!(res1 && res2));
            return result;
        }
        
++++3. Изменить функции MSolution
        /// <summary>
        /// NR-Открыть Солюшен
        /// </summary>
        /// <param name="solutionFilePath">Путь к Файлу Солюшена</param>
        /// <param name="readOnly">Открыть Солюшен в режиме Только чтение</param>
        public void SolutionOpen(string solutionFilePath, bool readOnly)
        {
            //1) load settings file
            MSolutionSettings sett = MSolutionSettings.Load(solutionFilePath);
            this.m_Settings = sett;
            //2) Добавить ссылку на солюшен в MSolutionRefCollection при открытии солюшена
            MSolutionRefCollection.AddSolutionReference(this);

            //Поддержка режима Только Чтение в Солюшене
            //сохранить текущий ReadOnly режим в настройках Солюшена и открывать солюшен дальше.
            this.m_Settings.SolutionReadOnly = this.checkReadOnlyMode(readOnly);    

            this.m_DbAdapter.Open(sett);//тут уже надо знать режим только-чтение

            //throw new NotImplementedException();//TODO: Add code here...
        }
 
        /// <summary>
        /// NR-Открыть Солюшен
        /// </summary>
        /// <param name="solutionFilePath">Путь к Файлу Солюшена</param>
        public void SolutionOpen(string solutionFilePath)
        {
            SolutionOpen(solutionFilePath, false);
        }
        
        /// <summary>
        /// NR-Закрыть Солюшен
        /// </summary>
        /// <remarks></remarks>
        /// <param name="withSave">Выполнять сохранение Солюшена перед закрытием</param>
        public void SolutionClose(bool withSave)
        {
            //Удалить ссылку на солюшен из MSolutionRefCollection при закрытии солюшена
            MSolutionRefCollection.RemoveSolutionReference(this, true);//false - игнорировать отсутствие, true - исключение при отсутствии.
            
            //Сохранить файл настроек Солюшена, если каталог Солюшена допускает Сохранение
            if(Bar.Utility.MUtility.isFolderWritable(this.m_Settings.getCurrentSolutionDirectory()))
                this.m_Settings.Save();
            //throw new NotImplementedException();//TODO: Add code here...
        }
        
++++4. Изменить класс BaseDbAdapter и производные классы
        /// <summary>
        /// Флаг режима Read-only из объекта Настроек Солюшена
        /// </summary>
        private bool m_ReadOnly;
        
        /// <summary>
        /// Конструктор
        /// </summary>
        /// <param name="solutionRef">Ссылка на объект Солюшена</param>
        public BaseDbAdapter(MSolution solutionRef)
        {
            m_Solution = solutionRef;
            //TODO: Add code here...
        }

        /// <summary>
        /// Флаг режима Read-only
        /// </summary>
        public bool ReadOnly
        {
            get { return m_ReadOnly; }
            //set { m_ReadOnly = value; }
        }

        /// <summary>
        /// NR-Открыть менеджер
        /// </summary>
        /// <param name="settings"></param>
        public void Open(MSolutionSettings settings)
        {
            //установить флаг read-only из настроек солюшена.
            //но это надо делать здесь а не в конструкторе, 
            //так как при создании адаптера еще неизвестно какой будет флаг read-only.
            //см. MSolution.SolutionOpen() функцию
            this.m_ReadOnly = this.m_Solution.SolutionReadOnly;
            //TODO: Add code here...
        }

        /// <summary>
        /// NT-Выбросить исключение если активен режим Только чтение
        /// </summary>
        /// <remarks>
        /// Использовать эту функцию для проверки флага "Только чтение" и завершения работы функций, изменяющих БД.
        /// </remarks>
        public void ThrowIfReadOnly()
        {
            if (this.m_ReadOnly == true)
                throw new SimEngineException("Database in Read-only mode");
            
            return;
        }

        /// <summary>
        /// NR-Создать строку соединения с БД
        /// </summary>
        /// <param name="dbFile">Путь к файлу БД</param>
        /// <param name="ReadOnly">Открыть в режиме ReadOnly</param>
        public virtual string createConnectionString(string dbFile, bool ReadOnly)
        {
            ////Provider=Microsoft.Jet.OLEDB.4.0;Data Source="C:\Documents and Settings\salomatin\Мои документы\Visual Studio 2008\Projects\RadioBase\радиодетали.mdb"
            //OleDbConnectionStringBuilder b = new OleDbConnectionStringBuilder();
            //b.Provider = "Microsoft.Jet.OLEDB.4.0";
            //b.DataSource = dbFile;
            ////это только для БД на незаписываемых дисках
            //if (ReadOnly)
            //{
            //    b.Add("Mode", "Share Deny Write");
            //}
            ////user id and password can specify here
            //return b.ConnectionString;

            throw new NotImplementedException();//Этот код только для примера
        }

        /// <summary>
        /// NT-Проверить, может ли данный адаптер работать, если Солюшен находится на компакт-диске
        /// </summary>
        /// <returns>Возвращает true, если данный адаптер может работать с read-only, false - если нет.</returns>
        /// <remarks>
        /// Функция должна быть перегружена в производных классах.
        /// Текущий код только для примера, для файловых БД вроде MSAccess
        /// </remarks>
        public virtual bool isCanWorkAtReadOnly()
        {
            //1 проверить каталог БД на запись.
            //это потому, что каталог БД в солюшене может назначаться отдельно от каталога Солюшена
            //поэтому может оказаться доступным для записи, то есть, БД работать может.
            bool res1 = Bar.Utility.MUtility.isFolderWritable(this.m_Solution.Settings.SolutionDatabaseDirectory);
            //2 если каталог БД все же read-only, возвращаем значение
            //может ли мы его заставить работать здесь в read-only.
            if (res1 == true)
                return true;
            else
            {
                return false;//Я не знаю как заставить текущую БД работать в read-only режиме
            }
        }

++++5. Добавить функции в класс MUtility
       /// <summary>
        /// NT-Проверить что каталог доступен для записи
        /// </summary>
        /// <param name="folderPath">Путь к проверяемому каталогу</param>
        /// <returns>Возвращает true, если каталог доступен для записи, иначе false.</returns>
        /// <remarks>
        /// Для проверки возможности записи в каталог функция создает в нем файл "writetest.txt".
        /// Если при этом выбрасывается любое исключение, то функция перехватывает его и возвращает отрицательный результат. 
        /// </remarks>
        internal static bool isFolderWritable(string folderPath)
        {
            bool ro = false;
            //generate test file name
            String test = Path.Combine(folderPath, "writetest.txt");
            try
            {
                //if test file already exists, its writable folder
                if (File.Exists(test))
                    File.Delete(test);//тут тоже будет исключение, если каталог read-only
                //test creation of new file
                FileStream fs = File.Create(test);
                fs.Close();
            }
            catch (Exception)
            {
                ro = true;
            }
            finally
            {
                File.Delete(test);
            }
            return (!ro);
        }

        /// <summary>
        /// RT-Вернуть абсолютный путь к каталогу
        /// </summary>
        /// <param name="basedir">Абсолютный путь основного каталога</param>
        /// <param name="localPath">Относительный или абсолютный путь конечного каталога</param>
        /// <returns>Функция возвращает абсолютный путь к конечному каталогу</returns>
        public static string makeAbsolutePath(string basedir, string localPath)
        {
            //проверяем  аргументы
            if(String.IsNullOrEmpty(basedir))
                throw new ArgumentException("Неправильный путь каталога", "basedir");
            if (localPath == null)
                throw new ArgumentException("Неправильный путь каталога", "localPath");
            if (!IsAbsolutePath(basedir))
                throw new ArgumentException("Путь должен быть абсолютным", "basedir");
            //если первый символ \, то удалить его, иначе пути не склеятся этой функцией
            String locP = localPath.Trim();
            if (locP.StartsWith("\\"))
                locP = locP.Substring(1);
            if (locP.EndsWith("\\"))
                locP = locP.Remove(locP.Length - 1);
            //если localPath не относительный, возвращаем его            
            if (IsAbsolutePath(locP))
                return locP;
            //иначе создаем абсолютный путь из локального и базового 
            String result = Path.Combine(basedir, locP);

            return result;
        }

        /// <summary>
        /// RT-Вернуть относительный (если возможно) или абсолютный путь к каталогу
        /// </summary>
        /// <param name="basedir">Абсолютный путь основного каталога</param>
        /// <param name="absolutePath">Относительный или абсолютный путь конечного каталога</param>
        /// <returns></returns>
        public static string makeRelativePath(string basedir, string absolutePath)
        {
            //проверяем аргументы
            if (String.IsNullOrEmpty(basedir))
                throw new ArgumentException("Неправильный путь каталога", "basedir");
            if (absolutePath == null)
                throw new ArgumentException("Неправильный путь каталога", "absolutePath");
            if (!IsAbsolutePath(basedir))
                throw new ArgumentException("Путь должен быть абсолютным", "basedir");
            //удалить конечный слеш в базовом каталоге если он есть
            String basePath = basedir.Trim();
            if (basePath.EndsWith("\\"))
                basePath = basePath.Remove(basePath.Length - 1);
            //удалить начальный и конечный слеш в пути конечного каталога, если они есть
            String absPath = absolutePath.Trim();
            if (absPath.StartsWith("\\"))
                absPath = absPath.Substring(1);
            if (absPath.EndsWith("\\"))
                absPath = absPath.Remove(absPath.Length - 1);
            //если absolutePath - абсолютный
            if (IsAbsolutePath(absPath))
            {
                //то надо определить, приводится ли он в относительный путь
                //и если не приводится, то вернуть целиком
                //а если приводится, то вернуть относительную часть.
                String p1 = Path.GetFullPath(basePath);
                String p2 = Path.GetFullPath(absPath);
                bool res = p2.StartsWith(p1, StringComparison.InvariantCultureIgnoreCase);
                if (res == true)//если absolutePath начинается с basedir, то он и приводится в относительный путь.
                {
                    string result = p2.Remove(0, p1.Length);
                    if (result.StartsWith("\\"))//TODO: проверить это при отладке и сразу упростить, если возможно.
                        result = result.Substring(1);
                    return result;
                }
                else
                    return absPath;//поскольку не приводится, то вернуть целиком
            }
            else
            {
                //если absolutePath - относительный, просто копируем его.
                return absPath;
            }
        }

        /// <summary>
        /// RT-Убедиться что файловый путь является абсолютным
        /// </summary>
        /// <param name="p">Проверяемый файловый путь, не сетевой.</param>
        /// <returns></returns>
        public static bool IsAbsolutePath(string p)
        {
            if (p == null) throw new ArgumentException("Path is null", "p");
            //если путь - пустая строка то это точно локальный путь.
            if (p == String.Empty)
                return false;
            //проверяем
            String vol = Path.GetPathRoot(p);
            //returns "" or "\" for relative path, and "C:\" for absolute path
            if (vol.Length != 3)
                return false;
            //первый символ должен быть буквой дискового тома
            return (Char.IsLetter(vol, 0));
        }

+++Отзывы
Оказались ли принятые решения правильными и почему/почему нет.

+++Документация - не закончена
todo: Описать происходящие процессы и написать текст для документации
Для лучшего понимания кода и написания документации Движка.
 
Поддержка режима Только чтение для Солюшена.

По умолчанию Солюшен открывается в обычном режиме - для чтения и записи.
Но его можно специально открыть в режиме Только для чтения.
При этом в нем можно будет создавать временные ячейки и связи, но нельзя будет изменять постоянные ячейки и связи, сохранить свойства Солюшена и Контейнера, итп.

Можно ли будет создавать файлы снимков Солюшена - я пока не решил. Надо подумать об этом.
 
Если же Солюшен размещен на носителе, не поддерживающем запись, то в процессе открытия он проверяет возможность записи в каталог солюшена и устанавливает флаг режима Только для чтения. 
Если солюшен специально открыт в режиме Только для чтения то проверка возможности записи не производится а сразу устанавливается флаг  режима Только для чтения. 

Также, Адаптер БД также участвует в проверке. Если адаптер БД способен работать с БД в режиме Только для чтения, то он возвращает сигнал об этом. Это возможно и тогда, когда каталог БД солюшена допускает запись. Это возможно, если он находится вне Каталога Солюшена. 
Но сейчас это не используется. Если Каталог Солюшена не доступен для записи, то Солюшен переводится в режим Только для чтения.  
 
 
Если Каталог Солюшена недоступен для записи, то:
 * Настройки Солюшена не сохраняются в Файл Солюшена при закрытии Солюшена.
 *  
 