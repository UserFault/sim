++ Задача Разработать Способ Получения Объекта Солюшена
[template: ШаблонКарточкиЗадачи]

+++Состояние задачи
* Экспериментальное решение найдено, но может оказаться неверным.
* Решена, но еще могут быть изменения. 02.01.2019 19:29:23


+++Задание
Придумать, как получить ссылку на контейнер и его объекты.

+++Зависимости
*  ЗадачаСоздатьМеханизмДоступаКСолюшену

+++Материалы
 * Ссылки на источники данных

+++Обсуждение и принятые решения
В старом коде ссылка на нужные объекты происходит через статическую ссылку в классе MCell.
Благодаря ей код получает ссылку на контейнер из любого места.
Но это предполагает, что в текущем процессе приложения может одновременно быть всего один контейнер как один открытый солюшен.

Собственно, эта ссылка должна быть на главный объект Солюшена: Контейнер или Солюшен.
И ее можно использовать из любого места кода в таком случае.
Но надо избегать такого, надо ссылку на Главный объект явно добавлять в другие объекты.
Кроме, наверно, ячеек и связей - их слишком много для такого способа.

И также константы-настройки Солюшена - они тоже получаются статическими и тоже действуют подобным же образом.
 Что же теперь - и константы настроек делать инстантными?
Это надо подумать!!!

Надо придумать:
- как в одном процессе держать несколько разных экземпляров Солюшенов.
- Как коду просто и быстро получать доступ к текущему Солюшену для доступа к его компонентам.
  Из кода классов ячеек и связей - там нет обычной backref-ссылки на контейнер.
- Как коду получать доступ к другим солюшенам по их идентификатору? 

Решение: новый статический класс MSolutionRefCollection. Предоставляет ссылку на солюшен по его идентификатору. Который есть у ячеек и связей. Теоретически, это будет правильно работать для двух разных солюшенов в одном процессе. Но это пока экспериментальное решение.

++++02 января 2019 - ссылка на солюшен в каждом объекте 
Механизм доступа к солюшену из связи медленный и в целом, не удался.
* Решено добавить ссылку на солюшен в каждый объект, производный от класса MElement. Поскольку механизм MSolutionRefCollection уж очень медленный, а ссылка требуется часто. Поэтому она теперь встроена в каждый объект элемента Движка. И даже так она слишком медленно доступна.
* Ранее считалось что это слишком много памяти сожрет. Но в текущей версии Движка память все равно занята всякой хренью, так что на другие поля место находится. Поэтому решено ввести это поле.
* Инициализировать ссылку на Солюшен через конструктор объекта.
* Механизм MSolutionRefCollection решено сохранить для сложных случаев.
    

+++Выполняемые действия
 * Добавить проперти Solution в класс MElement.
 * Реализовать проперти в каждом производном классе, добавив в него локальное поле m_Solution.
 * Изменить конструкторы классов, они должны принимать ссылку на объект Солюшена.
 * Изменить конструкторы копирования, они должны копировать также и ссылку на Солюшен.
 * Изменить код, использующий доступ к объекту Солюшена

++++1. Класс MElement
Добавить код
        /// <summary>
        /// Ссылка на объект Солюшена
        /// </summary>
        public abstract MSolution Solution
        {
            get;
        }
        
++++2. Класс MContainer 
Добавить код:
        /// <summary>
        /// Обратная ссылка на Солюшен
        /// </summary>
        private MSolution m_Solution;
        
        /// <summary>
        /// NR-Конструктор
        /// </summary>
        /// <param name="solutionRef">Ссылка на объект Солюшена</param>
        public MContainer(MSolution solutionRef)
        {
            m_Solution = solutionRef;
            //TODO: определиться, когда и где создавать объект адаптера БД и откуда его брать сюда для m_DbAdapter;
            //потому что нужен он будет и тут и везде.

            //создать менеджеры идентификаторов ячеек и связей
            //адаптер БД здесь сейчас не используется
            this.m_CellIdManager = new MCellIdManager(this);
            this.m_LinkIdManager = new MLinkIdManager(this);

            //TODO: Add code here...
        }
        
                /// <summary>
        /// Ссылка на объект Солюшена
        /// </summary>
        public override MSolution Solution
        {
            get { return this.m_Solution; }
        }
        
++++3. Класс MCell
Добавить код, наследуемый производными классами MCellA MCellB:

        /// <summary>
        /// Ссылка на объект Солюшена
        /// </summary>
        protected MSolution m_Solution;
        
        /// <summary>
        /// Protected constructor
        /// </summary>
        /// <param name="sol">Объект Солюшена</param>
        protected MCell(MSolution sol)
        {
            this.m_Solution = sol;
        }
        
        /// <summary>
        /// Ссылка на объект Солюшена
        /// </summary>
        public override MSolution Solution
        {
            get { return m_Solution; }
        }
        
        собственного конструктора нет пока

++++4. Класс MCellA
Добавить код:
        /// <summary>
        /// NR-Конструктор 
        /// </summary>
        /// <param name="sol">Объект Солюшена</param>
        public MCellA(MSolution sol) : base(sol)
        {
            //TODO: Add code here...
        }
        
++++5  Класс MCellB 
Добавить код:
        //TODO: добавить конструктор и поля класса MCellB
        /// <summary>
        /// NR-Конструктор 
        /// </summary>
        /// <param name="sol">Объект Солюшена</param>
        public MCellB(MSolution sol) : base(sol)
        {
            //TODO: Add code here...
        }
        
++++6. Класс MLink
Добавить код:
        /// <summary>
        /// Обратная ссылка на Солюшен
        /// </summary>
        private MSolution m_Solution;

        /// <summary>
        /// NT- Constructor
        /// Нигде не может пригодиться.
        /// </summary>
        public MLink()
        {
            this.m_description = String.Empty;
            this.m_downcell = null;
            this.m_downcellid = 0;
            this.m_isactive = true;
            this.m_linkClass = 0;
            this.m_linkId = 0;
            this.m_linkState = 0;
            this.m_serviceflag = 0;
            this.m_upcell = null;
            this.m_upcellid = 0;
            this.m_ReadOnly = false;
            this.m_lastChange = DateTime.MinValue;
            this.m_lastCreate = DateTime.MaxValue;
            this.m_Solution = null;
        }
        /// <summary>
        /// NT-Конструктор создания существующей ячейки
        /// </summary>
        /// <param name="sol">Текущий солюшен</param>
        /// <param name="id">Идентификатор связи</param>
        /// <param name="downCellID">Идентификатор нижней ячейки</param>
        /// <param name="upCellID">Идентификатор верхней ячейки</param>
        /// <param name="active">Флаг активности ячейки</param>
        /// <param name="linkClass">Идентификатор ячейки типа (оси) связи</param>
        /// <param name="linkState">Идентификатор ячейки состояния связи</param>
        /// <param name="service">Сервисное значение</param>
        /// <param name="description">Описание связи</param>
        /// <param name="readOnly">Режим Только чтение</param>
        /// <param name="created">Таймштамп создания связи</param>
        /// <param name="changed">Таймштамп изменения связи</param>
        public MLink(MSolution sol, MLinkId id, MCellId downCellID, MCellId upCellID,
            bool active, MCellId linkClass, MCellId linkState,
            Int32 service, String description, bool readOnly, DateTime created, DateTime changed)
        {
            this.m_Solution = sol;
            this.m_description = description;
            this.m_downcell = null;
            this.m_downcellid = downCellID.ToU64();
            this.m_isactive = active;
            this.m_linkClass = linkClass.ToU64();
            this.m_linkId = id.ToU64();
            this.m_linkState = linkState.ToU64();
            this.m_serviceflag = service;
            this.m_upcell = null;
            this.m_upcellid = upCellID.ToU64();
            this.m_ReadOnly = readOnly;
            //set timestamp
            this.m_lastCreate = created;
            this.m_lastChange = changed;

            return;
        }
        /// <summary>
        /// Ссылка на объект Солюшена
        /// </summary>
        public override MSolution Solution
        {
            get { return m_Solution; }
        }

+++Отзывы
Оказались ли принятые решения правильными и почему/почему нет.

+++Документация
todo: Описать происходящие процессы и написать текст для документации
Для лучшего понимания кода и написания документации Движка.
 