Описаны только существенные для менеджера функции.


Переменные класса:

        /// <summary>
        /// Название файла описания хранилища
        /// </summary>
        internal const string DescriptionFileName = "description.xml";

        /// <summary>
        /// путь к корневому каталогу хранилища.
        /// </summary>
        private string m_storageRootFolder;//TODO: переместить это поле в объект сеанса?

        /// <summary>
        /// флаг, что хранилище не поддерживает запись изменений.
        /// </summary>
        private bool m_ReadOnly;


Проперти класса:

        /// <summary>
        /// Корневой каталог Хранилища
        /// </summary>
        public string StorageFolder
        {
            get
            {
                return m_storageRootFolder;
            }
        }

        /// <summary>
        /// Получить флаг что хранилище может изменяться
        /// </summary>
        public bool ReadOnly
        {
            get
            {
                return isReadOnly(this.m_storageRootFolder);
            }
        }


Конструктор - деструктор:

        /// <summary>
        /// Конструктор
        /// </summary>
        public Manager()
        {
            //инициализация переменных для нового сеанса производится в функции Open
            this.m_ReadOnly = false;
            this.m_qualifiedStorageName = String.Empty;
            this.m_storageBaseClass = String.Empty;
            this.m_storageRootFolder = String.Empty;
        }

        /// <summary>
        /// Деструктор
        /// </summary>
        ~Manager()
        {

        }


Основные функции Хранилища:

        /// <summary>
        /// NFT-Создать Хранилище
        /// </summary>
        /// <returns>Возвращает готовый к работе, открытый менеджер Хранилища</returns>
        public static Manager CreateStorage(StorageInfo si)   

        /// <summary>
        /// NT-Начать сеанс работы с Хранилищем
        /// </summary>
        /// <param name="storagePath">Путь к каталогу Хранилища</param>
        public void Open(String storagePath)
        
        /// <summary>
        /// NT-Завершить сеанс работы с Хранилищем
        /// </summary>
        public void Close()

        /// <summary>
        /// NFT-Очистить Хранилище
        /// </summary>
        /// <returns>Return True if success, False otherwise</returns>
        public bool ClearStorage()

        /// <summary>
        /// NR-Оптимизация Хранилища - незакончено, неясно как сделать и как использовать потом
        /// </summary>
        public void OptimizeStorage()
        {
            CheckReadOnly();
            //сбросить буферизированные файлы в архивы, чтобы они не портили мне всю схему
            this.FlushBuffered();
            throw new System.NotImplementedException();
        }

        /// <summary>
        /// NFT-Удалить Хранилище
        /// </summary>
        /// <param name="storagePath">Путь к каталогу Хранилища</param>
        /// <returns>Возвращает true, если Хранилище успешно удалено или его каталог не существует.
        /// Возвращает false, если удалить Хранилище не удалось по какой-либо причине.</returns>
        public static bool DeleteStorage(String storagePath)





Функции информации о Хранилище:

public void ChangeStorageInfo(StorageInfo si)//NFT-Изменить свойства Хранилища.

        /// <summary>
        /// NT-Получить информацию о Хранилище
        /// </summary>
        public StorageInfo GetStorageInfo()

         /// <summary>
        /// NT-Записать в файл описания хранилища данные о состоянии хранилища
        /// </summary>
        private void updateStorageInfo()
        {
            //silent skip if read-only
            if (m_ReadOnly) 
                return;
            //get storage statistics
            StorageInfo si = GetStorageInfo();
            //write storage description file
            StorageInfo.StoreInfo(si);
            //update database storage info
            this.m_db.storeStorageInfo(si);

            return;
        } 

Функции, обслуживающие режим Только для чтения

        /// <summary>
        /// NT-Проверить режим read-only и выбросить исключение
        /// </summary>
        private void CheckReadOnly()
        {
            if (this.m_ReadOnly == true)
                throw new Exception("Error: Writing to read-only storage!");
        }

        /// <summary>
        /// NT-Возвращает флаг что указанное Хранилище может обновляться.
        /// </summary>
        /// <returns>Returns True if storage is ReadOnly, False otherwise</returns>
        private static bool isReadOnly(String storageRootFolder)
        {
            bool ro = false;
            //generate test file name
            String test = Path.Combine(storageRootFolder, "writetest.txt");
            //if test file already exists, its writable folder
            if (File.Exists(test))
                return true;
            //test creation 
            try
            {
                FileStream fs = File.Create(test);
                fs.Close();
            }
            catch (Exception)
            {
                ro = true;
            }
            finally
            {
                File.Delete(test);
            }
            return ro;
        }



Важные вспомогательные функции:

        /// <summary>
        /// NT-Извлечь файл шаблона базы данных из ресурсов сборки
        /// </summary>
        /// <param name="filepath">Путь к итоговому файлу</param>
        private static void extractDbFile(string filepath)
        {
            FileStream fs = new FileStream(filepath, FileMode.Create);
            byte[] content = Properties.Resources._base;//database template name
            fs.Write(content, 0, content.Length);
            fs.Close();
        }
        
        /// <summary>
        /// NT-Получить строку версии текущей сборки
        /// </summary>
        /// <returns></returns>
        public static string getEngineVersionString()
        {
            //DONE: Убедиться что это возвращает версию текущей сборки а не приложения.
            return Assembly.GetExecutingAssembly().GetName().Version.ToString();
        }

        
        /// <summary>
        /// NT-Проверить, что указанный каталог является каталогом Хранилища
        /// </summary>
        /// <param name="path">Путь к каталогу</param>
        /// <returns>Возвращает true, если каталог является каталогом Хранилища. В противном случае возвращает false</returns>
        public static bool IsStorageFolder(string path)
        {
            //критерии:
            //папка должна содержать файл "description.xml"
            //папка должна содержать файл db.mdb
            //папка должна содержать папки docs pics
            //файл "description.xml" должен читаться без проблем
            
            String p = Path.Combine(path, ArchiveController.DocumentsDir);
            if (!Directory.Exists(p)) return false;
            p = Path.Combine(path, ArchiveController.ImagesDir);
            if (!Directory.Exists(p)) return false;
            p = Path.Combine(path, DbAdapter.DatabaseFileName);
            if (!File.Exists(p)) return false;
            p = Path.Combine(path, Manager.DescriptionFileName);
            if (!File.Exists(p)) return false;
            //try load descr file
            bool result = true;
            try
            {
                StorageInfo si = StorageInfo.GetInfo(path);
            }
            catch (Exception)
            {
                result = false;
            }
            return result;
        }
        
         /// <summary>
        /// NT-Открыть хранилище один раз при его создании, 
        /// когда БД еще не содержит всех нужных данных, а ее уже надо открыть.  
        /// </summary>
        /// <param name="si"></param>
        private void openIfNewOnly(StorageInfo si)


         public override string ToString()
        {
            return base.ToString();
        } 

        





        



        

                
             
        
                                                              